/*
 * Copyright 2018 Google Inc.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**************************************************************************************************
 *** This file was autogenerated from GrRectBlurEffect.fp; do not modify.
 **************************************************************************************************/
#include "GrRectBlurEffect.h"

#include "src/core/SkUtils.h"
#include "src/gpu/GrTexture.h"
#include "src/gpu/glsl/GrGLSLFragmentProcessor.h"
#include "src/gpu/glsl/GrGLSLFragmentShaderBuilder.h"
#include "src/gpu/glsl/GrGLSLProgramBuilder.h"
#include "src/sksl/SkSLCPP.h"
#include "src/sksl/SkSLUtil.h"
class GrGLSLRectBlurEffect : public GrGLSLFragmentProcessor {
public:
    GrGLSLRectBlurEffect() {}
    void emitCode(EmitArgs& args) override {
        GrGLSLFPFragmentBuilder* fragBuilder = args.fFragBuilder;
        const GrRectBlurEffect& _outer = args.fFp.cast<GrRectBlurEffect>();
        (void)_outer;
        auto rect = _outer.rect;
        (void)rect;
        auto isFast = _outer.isFast;
        (void)isFast;
        rectVar = args.fUniformHandler->addUniform(
                &_outer, kFragment_GrShaderFlag, kFloat4_GrSLType, "rect");
        fragBuilder->codeAppendf(
                R"SkSL(half xCoverage;
half yCoverage;

@if (%s) {
    half2 xy = max(half2(%s.xy - %s), half2(%s - %s.zw));)SkSL",
                (_outer.isFast ? "true" : "false"),
                args.fUniformHandler->getUniformCStr(rectVar),
                args.fSampleCoord,
                args.fSampleCoord,
                args.fUniformHandler->getUniformCStr(rectVar));
        SkString _coords0("float2(half2(xy.x, 0.5))");
        SkString _sample0 = this->invokeChild(0, args, _coords0.c_str());
        fragBuilder->codeAppendf(
                R"SkSL(
    xCoverage = %s.w;)SkSL",
                _sample0.c_str());
        SkString _coords1("float2(half2(xy.y, 0.5))");
        SkString _sample1 = this->invokeChild(0, args, _coords1.c_str());
        fragBuilder->codeAppendf(
                R"SkSL(
    yCoverage = %s.w;
} else {
    half4 rect = half4(half2(%s.xy - %s), half2(%s - %s.zw));)SkSL",
                _sample1.c_str(),
                args.fUniformHandler->getUniformCStr(rectVar),
                args.fSampleCoord,
                args.fSampleCoord,
                args.fUniformHandler->getUniformCStr(rectVar));
        SkString _coords2("float2(half2(rect.x, 0.5))");
        SkString _sample2 = this->invokeChild(0, args, _coords2.c_str());
        SkString _coords3("float2(half2(rect.z, 0.5))");
        SkString _sample3 = this->invokeChild(0, args, _coords3.c_str());
        fragBuilder->codeAppendf(
                R"SkSL(
    xCoverage = (1.0 - %s.w) - %s.w;)SkSL",
                _sample2.c_str(),
                _sample3.c_str());
        SkString _coords4("float2(half2(rect.y, 0.5))");
        SkString _sample4 = this->invokeChild(0, args, _coords4.c_str());
        SkString _coords5("float2(half2(rect.w, 0.5))");
        SkString _sample5 = this->invokeChild(0, args, _coords5.c_str());
        fragBuilder->codeAppendf(
                R"SkSL(
    yCoverage = (1.0 - %s.w) - %s.w;
}
return half4(xCoverage * yCoverage);
)SkSL",
                _sample4.c_str(),
                _sample5.c_str());
    }

private:
    void onSetData(const GrGLSLProgramDataManager& pdman,
                   const GrFragmentProcessor& _proc) override {
        const GrRectBlurEffect& _outer = _proc.cast<GrRectBlurEffect>();
        { pdman.set4fv(rectVar, 1, reinterpret_cast<const float*>(&_outer.rect)); }
    }
    UniformHandle rectVar;
};
std::unique_ptr<GrGLSLFragmentProcessor> GrRectBlurEffect::onMakeProgramImpl() const {
    return std::make_unique<GrGLSLRectBlurEffect>();
}
void GrRectBlurEffect::onGetGLSLProcessorKey(const GrShaderCaps& caps,
                                             GrProcessorKeyBuilder* b) const {
    b->addBool(isFast, "isFast");
}
bool GrRectBlurEffect::onIsEqual(const GrFragmentProcessor& other) const {
    const GrRectBlurEffect& that = other.cast<GrRectBlurEffect>();
    (void)that;
    if (rect != that.rect) return false;
    if (isFast != that.isFast) return false;
    return true;
}
GrRectBlurEffect::GrRectBlurEffect(const GrRectBlurEffect& src)
        : INHERITED(kGrRectBlurEffect_ClassID, src.optimizationFlags())
        , rect(src.rect)
        , isFast(src.isFast) {
    this->cloneAndRegisterAllChildProcessors(src);
    this->setUsesSampleCoordsDirectly();
}
std::unique_ptr<GrFragmentProcessor> GrRectBlurEffect::clone() const {
    return std::make_unique<GrRectBlurEffect>(*this);
}
#if GR_TEST_UTILS
SkString GrRectBlurEffect::onDumpInfo() const {
    return SkStringPrintf("(rect=float4(%f, %f, %f, %f), isFast=%s)",
                          rect.left(),
                          rect.top(),
                          rect.right(),
                          rect.bottom(),
                          (isFast ? "true" : "false"));
}
#endif
GR_DEFINE_FRAGMENT_PROCESSOR_TEST(GrRectBlurEffect);
#if GR_TEST_UTILS
std::unique_ptr<GrFragmentProcessor> GrRectBlurEffect::TestCreate(GrProcessorTestData* data) {
    float sigma = data->fRandom->nextRangeF(3, 8);
    int x = data->fRandom->nextRangeF(1, 200);
    int y = data->fRandom->nextRangeF(1, 200);
    float width = data->fRandom->nextRangeF(200, 300);
    float height = data->fRandom->nextRangeF(200, 300);
    SkMatrix vm = GrTest::TestMatrixPreservesRightAngles(data->fRandom);
    auto rect = SkRect::MakeXYWH(x, y, width, height);
    return GrRectBlurEffect::Make(
            data->inputFP(), data->context(), *data->caps()->shaderCaps(), rect, vm, sigma);
}
#endif
